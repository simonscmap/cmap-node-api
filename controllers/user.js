const jwt = require('jsonwebtoken');
const uuidv1 = require('uuid/v1');
const sql = require('mssql');
const {OAuth2Client} = require('google-auth-library');
const base64url = require('base64-url');

const jwtConfig = require('../config/jwtConfig');
const UnsafeUser = require('../models/UnsafeUser');
const userDBConfig = require ('../config/dbConfig').userTableConfig;
const awaitableEmailClient = require('../utility/emailAuth');
const emailTemplates = require('../utility/emailTemplates');
const templates = require('../utility/email/templates');
const guestTokenHashFromRequest = require('../utility/guestTokenHashFromRequest');
const sqlSegments = require('../utility/sqlSegments');
const sendMail = require('../utility/email/sendMail');

const initializeLogger = require('../log-service');
const log = initializeLogger('controllers/user');

const apiKeyTable = 'tblApi_Keys'

const cmapClientID = '739716651449-7d1e8iijue6srr9l5mi2iogp982sqoa0.apps.googleusercontent.com';

var pools = require('../dbHandlers/dbPools');
const datasetCatalogQuery = require('../dbHandlers/datasetCatalogQuery');

const standardCookieOptions = {
    // secure: true,
}

const jwtCookieOptions = {
    ...standardCookieOptions,
    httpOnly: true
}

// Creates a new user in DB. Sends confirmation email
exports.signup = async (req, res, next) => {
  // Registers a new user.
  let newUser = new UnsafeUser(req.body);
  let signupResult = await newUser.saveAsNew();

  if(!(signupResult.rowsAffected && signupResult.rowsAffected[0] > 0)){
    res.sendStatus(400);
    return next();
  }

  let signedUpUser = await UnsafeUser.getUserByEmail(req.body.email);

  let emailClient = await awaitableEmailClient;

  // jwt payload is just `{ iss, sub }`
  let jwtPayload = signedUpUser.getJWTPayload();

  let token = jwt.sign(jwtPayload, jwtConfig.secret, { expiresIn: 60 * 60 * 24 });

  let content = emailTemplates.confirmEmail(token);
  let message =
    "From: 'me'\r\n" +
    "To: " + newUser.email + "\r\n" +
    "Subject: Simons CMAP\r\n" +
    "Content-Type: text/html; charset='UTF-8'\r\n" +
    "Content-Transfer-Encoding: base64\r\n\r\n" +
    content;

  let raw = base64url.encode(message);

  let result;

  try {
    result = await emailClient.users.messages.send({
      // https://developers.google.com/gmail/api/reference/rest/v1/users.messages/send
      // 'me' is a special value, indicating to use the authenticated user
      // which, in this case, is the one stored in credentials.json
      userId: 'me',
      resource: {
        raw
      }
    });

    res.sendStatus(200);
  } catch (e) {
    console.log('error sending mail, check if token is valid', e, result);
  }

  return next();
}

 // Sends JWT http-only cookie
 exports.signin = async (req, res, next) => {
    // If requests authenticates we sent a cookie with basic user info, and
    // and httpOnly cookie with the JWT.
    let user = new UnsafeUser(req.user);
    res.cookie('UserInfo', JSON.stringify(new UnsafeUser(req.user).makeSafe()), {...standardCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2)});
    res.cookie('jwt', await jwt.sign(user.getJWTPayload(), jwtConfig.secret, {expiresIn:'2h'}), {...jwtCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2)});

    res.json(true);
    next();
}

// Confirms unique username and email
exports.validate = async(req, res, next) => {
    // Confirms uniqueness of username and password.
    let unsafeUser = new UnsafeUser(req.body);
    res.json(await unsafeUser.validateUsernameAndEmail());
    next();
}

// Deletes http-only cookie (this cannot be done by client-side javascript)
exports.signout = async(_req, res, next) => {
    res.clearCookie('UserInfo');
    res.clearCookie('jwt', jwtCookieOptions)
    res.end();
    next();
}

// Create an API key
exports.generateApiKey = async(req, res, next) => {
    let apiKey = uuidv1();
    let pool = await new sql.ConnectionPool(userDBConfig).connect();
    let request = new sql.Request(pool);
    request.input('description', sql.NVarChar, req.query.description);
    let query = `INSERT INTO ${apiKeyTable} (Api_Key, Description, User_ID) VALUES ('${apiKey}', @description, ${req.cmapApiCallDetails.userID})`;
    await request.query(query);
    res.json(true);
    next();
}

// Retrieve all API keys for a user
exports.retrieveApiKeys = async(req, res, next) => {
    let apiKeys = await UnsafeUser.getApiKeysByUserID(req.cmapApiCallDetails.userID);
    res.json({keys: apiKeys})
    next();
}

// Accepts a token generated by a successful google oauth sign-in. We verify token, then
// either create a new user or log in an existing user
exports.googleAuth = async(req, res, next) => {
    const client = new OAuth2Client(cmapClientID);
    const { userIDToken } = req.body;
    const ticket = await client.verifyIdToken({
        idToken: userIDToken,
        audience: cmapClientID
    })

    // our app client ID, user unique google ID, user email, first, last
    const { aud, sub: googleID, email, given_name: firstName, family_name: lastName } = ticket.payload;

    if(aud !== cmapClientID){
        return next();
    }

    // User already has a google ID associated with their account
    var googleIDUser = await UnsafeUser.getUserByGoogleID(googleID);

    if(googleIDUser) {
        let user = new UnsafeUser(googleIDUser);
        res.cookie('UserInfo', JSON.stringify(user.makeSafe()), {...standardCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2)});
        res.cookie('jwt', jwt.sign(googleIDUser.getJWTPayload(), jwtConfig.secret, { expiresIn: '2h' }), {...jwtCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2)});
        res.json(true);
        return next();
    }

    // User has an account but has no associated google ID
    var existingUser = await UnsafeUser.getUserByEmail(email);

    if(existingUser){
        let user = new UnsafeUser({...existingUser, googleID});

        await user.attachGoogleIDToExistingUser();

        res.cookie('UserInfo', JSON.stringify(user.makeSafe()), {...standardCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2)});
        res.cookie('jwt', jwt.sign(user.getJWTPayload(), jwtConfig.secret, {expiresIn:'2h'}), {...jwtCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2)});
        res.json(true);
        return next();
    }
    // New user
    let user = new UnsafeUser({
        googleID,
        email,
        firstName,
        lastName,
        username: email
    });

    await user.saveAsNew();

    res.cookie('UserInfo', JSON.stringify(user.makeSafe()), {...standardCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2)});
    res.cookie('jwt', jwt.sign(user.getJWTPayload(), jwtConfig.secret, {expiresIn:'2h'}), {...jwtCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2)});
    res.json(true);

    return next();
}

// Endpoint for user profile self update
exports.updateInfo = async(req, res, _next) => {
    let user = new UnsafeUser({...req.user, ...req.body.userInfo});
    let result = await user.updateUserProfile();
    if(!result.rowsAffected || !result.rowsAffected[0]) {
        return res.sendStatus(400);
    }
    res.cookie('UserInfo', JSON.stringify(user.makeSafe()), {...standardCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2)});
    return res.sendStatus(200);
}

// Sends forgot password email to registered email address
exports.forgotPassword = async(req, res, next) => {
  // Accepts post with email address, send forgotten password email with JWT in link to reset
  let user = new UnsafeUser(await UnsafeUser.getUserByEmail(req.body.email));

  if(!user || !user.email) {
    return res.sendStatus(200);
  }

  let token = jwt.sign(user.getJWTPayload(), jwtConfig.secret, { expiresIn: 60 * 30 });

  let content = templates.userResetPassword({ jwt: token });

  let subject = 'CMAP Password Reset Request';

  try {
    sendMail(user.email, subject, content);
  } catch (e) {
    res.sendStatus(500);
    log.error('error sending password reset email', e);
    return;
  }

  res.sendStatus(200);
  return next();
}

exports.contactUs = async(req, res, next) => {
    let payload = req.body;

    let emailClient = await awaitableEmailClient;
    let content = emailTemplates.contactUs(payload);
    let message =
        "From: 'me'\r\n" +
        "To: simonscmap@uw.edu\r\n" +
        "Subject: Message from Simons CMAP User\r\n" +
        // "Content-Type: text/html; charset='UTF-8'\r\n" +
        // "Content-Transfer-Encoding: base64\r\n\r\n" +
        content;

    let raw = base64url.encode(message);

    try {
        let result = await emailClient.users.messages.send({
            userId: 'me',
            resource: {
                raw
            }
        })

        res.sendStatus(200);
    } catch(e) {
        res.sendStatus(400);
    }

    return next();
}

// Endpoint for forgot password reset form
exports.choosePassword = async(req, res, next) => {
    let payload;
    try{
        payload = await jwt.verify(req.body.token, jwtConfig.secret);
    } catch {
        res.sendStatus(400);
        return next();
    }

    let password = req.body.password;
    let user = new UnsafeUser({id: payload.sub, password});
    let result = await user.updatePassword();

    if(result.rowsAffected && result.rowsAffected[0] > 0){
        res.sendStatus(200);
        return next();
    } else {
        console.log('rowsAffected fail')
        res.sendStatus(400);
        return next();
    }
}

exports.changeEmail = async(req, res, next) => {
    let user = new UnsafeUser({...req.user, email: req.body.email});
    try{
        let result = await user.updateEmail();
        res.cookie('UserInfo', JSON.stringify(user.makeSafe()), {...standardCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2)});
        return res.sendStatus(200);
    } catch(e) {
        if(e.code === 'EREQUEST'){
            return res.sendStatus(409);
        }
        res.sendStatus(400);
    }
    // if(!result.rowsAffected || !result.rowsAffected[0]) return res.sendStatus(400);
}

// Endpoint for user profile self-update password
exports.changePassword = async(req, res, next) => {
    let user = new UnsafeUser({...req.user, password: req.body.newPassword});
    let result = await user.updatePassword();
    if(!result.rowsAffected || !result.rowsAffected[0]) return res.sendStatus(400);
    return res.sendStatus(200);
}

// Persist favorite to DB
exports.addCartItem = async(req, res, next) => {
    let pool = await pools.userReadAndWritePool;
    let request = await new sql.Request(pool);

    request.input('userID', sql.Int, req.user.id);
    request.input('datasetID', sql.Int, req.body.itemID);

    const query = 'INSERT INTO [dbo].[tblUser_Dataset_Favorites] (User_ID, Dataset_ID) VALUES (@userID, @datasetID)';

    try {
        let result = await request.query(query);
    }

    catch(e) {
        console.log(e);
    }

    res.end();
    return next();
}

// Remove persisted favorite from DB
exports.removeCartItem = async(req, res, next) => {
    let pool = await pools.userReadAndWritePool;
    let request = new sql.Request(pool);

    request.input('userID', sql.Int, req.user.id);
    request.input('datasetID', sql.Int, req.body.itemID);

    const query = 'DELETE FROM [dbo].[tblUser_Dataset_Favorites] WHERE User_ID = @userID AND Dataset_ID = @datasetID';

    try {
        await request.query(query);
    } catch(e) {
        console.log(e);
    }

    res.end();
    return next();
}

// Remove all persisted favorites from db
exports.clearCart = async(req, res, next) => {
    let pool = await pools.userReadAndWritePool;
    let request = new sql.Request(pool);

    request.input('userID', sql.Int, req.user.id);

    const query = 'DELETE FROM [dbo].[tblUser_Dataset_Favorites] WHERE User_ID = @userID';

    try {
      await request.query(query);
    }

    catch(e) {
        console.log(e);
    }

    res.end();
    return next();
}

// Retrieve persisted favorites for a user
exports.getCart = async(req, res, next) => {
    let pool = await pools.userReadAndWritePool;
    let request = await new sql.Request(pool);

    request.input('userID', sql.Int, req.user.id);

    const query = datasetCatalogQuery +
        `
            AND cat.Dataset_ID IN (
                SELECT Dataset_ID
                FROM tblUser_Dataset_Favorites
                WHERE User_ID = @userID
            )
        `;

    try {
        let result = await request.query(query);
        let datasets = result.recordsets[0];
        datasets.forEach((e, i) => {
            e.Sensors = [... new Set(e.Sensors.split(','))];
        });
        res.send(JSON.stringify(datasets));
    }

    catch(e) {
        console.log(e);
    }

    res.end();
    return next();
}

// Generates and sends a guest token to user
exports.getGuestToken = async(req, res, next) => {
    let pool = await pools.userReadAndWritePool;

    let checkTokenLimitRequest = await new sql.Request(pool);
    let checkTokenLimitResult = await checkTokenLimitRequest.query(`
        ${sqlSegments.declareAndSetDateTimeVariables}

        SELECT * FROM [tblGuest_Tokens_Issued_Hourly]
        WHERE [Date_Time] = ${sqlSegments.dateTimeFromParts}
    `);

    if(checkTokenLimitResult.recordset && checkTokenLimitResult.recordset.length){
        let tokensIssuedThisHour = checkTokenLimitResult.recordset[0].Tokens_Issued;
        if(tokensIssuedThisHour > 200){
            res.sendStatus(503);
            return next();
        }
    }

    else {
        let addNewHourRowRequest = await new sql.Request(pool);
        let addNewHourRowResult;

        try {
            addNewHourRowResult = await addNewHourRowRequest.query(`
                ${sqlSegments.declareAndSetDateTimeVariables}
                INSERT INTO [tblGuest_Tokens_Issued_Hourly] ([Date_Time], [Tokens_Issued])
                VALUES ( ${sqlSegments.dateTimeFromParts}, 1)
            `);
        }

        catch(e) {
            if(e.number === 2601){
                // another node instance inserted this row during our network call.
                //Just increment
            }

            else {
                console.log(e)
                res.sendStatus(503);
                return next();
            }
        }
    }

    // if you're not going to increment a row and send back a token you should have exited the function by now
    let incrementTokensIssuedRequest = await new sql.Request(pool);
    incrementTokensIssuedRequest.query(`
        ${sqlSegments.declareAndSetDateTimeVariables}
        UPDATE [tblGuest_Tokens_Issued_Hourly]
        SET [Tokens_Issued] = [Tokens_Issued] + 1
        WHERE [Date_Time] = ${sqlSegments.dateTimeFromParts}
    `);

    let hash = guestTokenHashFromRequest(req);

    let storeTokenInfoRequest = await new sql.Request(pool);
    let storeTokenInfoResult = await storeTokenInfoRequest.query(`
        INSERT INTO tblGuest_Tokens ([Hash])
        Values ('${hash}')
        SELECT SCOPE_IDENTITY() AS ID
    `);

    let token = {
        id: storeTokenInfoResult.recordset[0].ID,
        hash
    };

    let expires = parseInt(req.query.expires);
    res.cookie('guestToken', await jwt.sign(token, jwtConfig.secret, {expiresIn:'24h'}), {expires: new Date(expires)});
    return res.sendStatus(200)
}
