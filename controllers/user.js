const jwt = require("jsonwebtoken");
const uuidv1 = require("uuid/v1");
const sql = require("mssql");
const { OAuth2Client } = require("google-auth-library");
const base64url = require("base64-url");

const jwtConfig = require("../config/jwtConfig");
const UnsafeUser = require("../models/UnsafeUser");
const userDBConfig = require("../config/dbConfig").userTableConfig;
const awaitableEmailClient = require("../utility/emailAuth");
const emailTemplates = require("../utility/emailTemplates");
const templates = require("../utility/email/templates");
const guestTokenHashFromRequest = require("../utility/guestTokenHashFromRequest");
const sqlSegments = require("../utility/sqlSegments");
const sendMail = require("../utility/email/sendMail");

const initializeLogger = require("../log-service");
const log = initializeLogger("controllers/user");

const apiKeyTable = "tblApi_Keys";

const cmapClientID =
  "739716651449-7d1e8iijue6srr9l5mi2iogp982sqoa0.apps.googleusercontent.com";

var pools = require("../dbHandlers/dbPools");
const datasetCatalogQuery = require("../dbHandlers/datasetCatalogQuery");

const standardCookieOptions = {
  // secure: true,
};

const jwtCookieOptions = {
  ...standardCookieOptions,
  httpOnly: true,
};

// Creates a new user in DB. Sends confirmation email
exports.signup = async (req, res, next) => {
  // Registers a new user.
  let newUser = new UnsafeUser(req.body);

  let signupResult;

  try {
    signupResult = await newUser.saveAsNew();
  } catch (e) {
    log.error("error saving new user", e);
    res.sendStatus(500);
    return;
  }

  if (!(signupResult.rowsAffected && signupResult.rowsAffected[0] > 0)) {
    res.sendStatus(400);
    return;
  }

  let signedUpUser;

  try {
    signedUpUser = await UnsafeUser.getUserByEmail(req.body.email);
  } catch (e) {
    log.error("error retrieving user during signup", { error: e, newUser });
  }

  // jwt payload is just `{ iss, sub }`
  let jwtPayload = signedUpUser.getJWTPayload();
  let token = jwt.sign(jwtPayload, jwtConfig.secret, {
    expiresIn: 60 * 60 * 24,
  });

  let addressee = signedUpUser.firstName;

  let content = templates.signupConfirmEmail({ jwt: token, addressee });
  let subject = "Simons CMAP: Confirm Account";
  try {
    await sendMail(req.body.email, subject, content);
    res.sendStatus(200);
  } catch (e) {
    log.error("error sending mail, check if token is valid", {
      error: e,
      result,
    });
    return res.sendStatus(500);
  }
};

// Sends JWT http-only cookie
exports.signin = async (req, res, next) => {
  // If requests authenticates we sent a cookie with basic user info, and
  // and httpOnly cookie with the JWT.
  let user = new UnsafeUser(req.user);
  res.cookie("UserInfo", JSON.stringify(new UnsafeUser(req.user).makeSafe()), {
    ...standardCookieOptions,
    expires: new Date(Date.now() + 1000 * 60 * 60 * 2),
  });
  res.cookie(
    "jwt",
    await jwt.sign(user.getJWTPayload(), jwtConfig.secret, { expiresIn: "2h" }),
    { ...jwtCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2) }
  );

  res.json(true);
  next();
};

// Confirms unique username and email
exports.validate = async (req, res, next) => {
  // Confirms uniqueness of username and password.
  let unsafeUser = new UnsafeUser(req.body);
  res.json(await unsafeUser.validateUsernameAndEmail());
  next();
};

// Deletes http-only cookie (this cannot be done by client-side javascript)
exports.signout = async (_req, res, next) => {
  res.clearCookie("UserInfo");
  res.clearCookie("jwt", jwtCookieOptions);
  res.end();
};

// Create an API key
exports.generateApiKey = async (req, res, next) => {
  let apiKey = uuidv1();
  let pool = await new sql.ConnectionPool(userDBConfig).connect();
  let request = new sql.Request(pool);
  request.input("description", sql.NVarChar, req.query.description);
  let query = `INSERT INTO ${apiKeyTable} (Api_Key, Description, User_ID) VALUES ('${apiKey}', @description, ${req.cmapApiCallDetails.userID})`;
  await request.query(query);
  res.json(true);
  next();
};

// Retrieve all API keys for a user
exports.retrieveApiKeys = async (req, res, next) => {
  let apiKeys = await UnsafeUser.getApiKeysByUserID(
    req.cmapApiCallDetails.userID
  );
  res.json({ keys: apiKeys });
  next();
};

// Accepts a token generated by a successful google oauth sign-in. We verify token, then
// either create a new user or log in an existing user
exports.googleAuth = async (req, res, next) => {
  const client = new OAuth2Client(cmapClientID);
  const { userIDToken } = req.body;
  const ticket = await client.verifyIdToken({
    idToken: userIDToken,
    audience: cmapClientID,
  });

  // our app client ID, user unique google ID, user email, first, last
  const {
    aud,
    sub: googleID,
    email,
    given_name: firstName,
    family_name: lastName,
  } = ticket.payload;

  if (aud !== cmapClientID) {
    return next();
  }

  // User already has a google ID associated with their account
  var googleIDUser = await UnsafeUser.getUserByGoogleID(googleID);

  if (googleIDUser) {
    let user = new UnsafeUser(googleIDUser);
    res.cookie("UserInfo", JSON.stringify(user.makeSafe()), {
      ...standardCookieOptions,
      expires: new Date(Date.now() + 1000 * 60 * 60 * 2),
    });
    res.cookie(
      "jwt",
      jwt.sign(googleIDUser.getJWTPayload(), jwtConfig.secret, {
        expiresIn: "2h",
      }),
      {
        ...jwtCookieOptions,
        expires: new Date(Date.now() + 1000 * 60 * 60 * 2),
      }
    );
    res.json(true);
    return next();
  }

  // User has an account but has no associated google ID
  var existingUser = await UnsafeUser.getUserByEmail(email);

  if (existingUser) {
    let user = new UnsafeUser({ ...existingUser, googleID });

    await user.attachGoogleIDToExistingUser();

    res.cookie("UserInfo", JSON.stringify(user.makeSafe()), {
      ...standardCookieOptions,
      expires: new Date(Date.now() + 1000 * 60 * 60 * 2),
    });
    res.cookie(
      "jwt",
      jwt.sign(user.getJWTPayload(), jwtConfig.secret, { expiresIn: "2h" }),
      {
        ...jwtCookieOptions,
        expires: new Date(Date.now() + 1000 * 60 * 60 * 2),
      }
    );
    res.json(true);
    return next();
  }
  // New user
  let user = new UnsafeUser({
    googleID,
    email,
    firstName,
    lastName,
    username: email,
  });

  await user.saveAsNew();

  res.cookie("UserInfo", JSON.stringify(user.makeSafe()), {
    ...standardCookieOptions,
    expires: new Date(Date.now() + 1000 * 60 * 60 * 2),
  });
  res.cookie(
    "jwt",
    jwt.sign(user.getJWTPayload(), jwtConfig.secret, { expiresIn: "2h" }),
    { ...jwtCookieOptions, expires: new Date(Date.now() + 1000 * 60 * 60 * 2) }
  );
  res.json(true);

  return next();
};

// Endpoint for user profile self update
exports.updateInfo = async (req, res, _next) => {
  let user = new UnsafeUser({ ...req.user, ...req.body.userInfo });
  let result = await user.updateUserProfile();
  if (!result.rowsAffected || !result.rowsAffected[0]) {
    return res.sendStatus(400);
  }
  res.cookie("UserInfo", JSON.stringify(user.makeSafe()), {
    ...standardCookieOptions,
    expires: new Date(Date.now() + 1000 * 60 * 60 * 2),
  });
  return res.sendStatus(200);
};

// Sends forgot password email to registered email address
exports.forgotPassword = async (req, res, next) => {
  // Accepts post with email address, send forgotten password email with JWT in link to reset
  let user = new UnsafeUser(await UnsafeUser.getUserByEmail(req.body.email));

  if (!user || !user.email) {
    return res.sendStatus(200);
  }

  let token = jwt.sign(user.getJWTPayload(), jwtConfig.secret, {
    expiresIn: 60 * 30,
  });

  let content = templates.userResetPassword({ jwt: token });

  let subject = "CMAP Password Reset Request";

  try {
    sendMail(user.email, subject, content);
  } catch (e) {
    res.sendStatus(500);
    log.error("error sending password reset email", e);
    return;
  }

  res.sendStatus(200);
  return next();
};

exports.contactUs = async (req, res, next) => {
  let payload = req.body;

  let emailClient = await awaitableEmailClient;
  let content = emailTemplates.contactUs(payload);
  let message =
    "From: 'me'\r\n" +
    "To: simonscmap@uw.edu\r\n" +
    "Subject: Message from Simons CMAP User\r\n" +
    // "Content-Type: text/html; charset='UTF-8'\r\n" +
    // "Content-Transfer-Encoding: base64\r\n\r\n" +
    content;

  let raw = base64url.encode(message);

  try {
    let result = await emailClient.users.messages.send({
      userId: "me",
      resource: {
        raw,
      },
    });

    res.sendStatus(200);
  } catch (e) {
    res.sendStatus(400);
  }

  return next();
};

// Endpoint for forgot password reset form
exports.choosePassword = async (req, res, next) => {
  let payload;
  try {
    payload = await jwt.verify(req.body.token, jwtConfig.secret);
  } catch {
    res.sendStatus(400);
    return next();
  }

  let password = req.body.password;
  let user = new UnsafeUser({ id: payload.sub, password });
  let result = await user.updatePassword();

  if (result.rowsAffected && result.rowsAffected[0] > 0) {
    res.sendStatus(200);
    return next();
  } else {
    console.log("rowsAffected fail");
    res.sendStatus(400);
    return next();
  }
};

exports.changeEmail = async (req, res, next) => {
  let user = new UnsafeUser({ ...req.user, email: req.body.email });
  try {
    let result = await user.updateEmail();
    res.cookie("UserInfo", JSON.stringify(user.makeSafe()), {
      ...standardCookieOptions,
      expires: new Date(Date.now() + 1000 * 60 * 60 * 2),
    });
    return res.sendStatus(200);
  } catch (e) {
    if (e.code === "EREQUEST") {
      return res.sendStatus(409);
    }
    res.sendStatus(400);
  }
  // if(!result.rowsAffected || !result.rowsAffected[0]) return res.sendStatus(400);
};

// Endpoint for user profile self-update password
exports.changePassword = async (req, res, next) => {
  let user = new UnsafeUser({ ...req.user, password: req.body.newPassword });
  let result = await user.updatePassword();
  if (!result.rowsAffected || !result.rowsAffected[0])
    return res.sendStatus(400);
  return res.sendStatus(200);
};

// Persist favorite to DB
exports.addCartItem = async (req, res, next) => {
  let pool = await pools.userReadAndWritePool;
  let request = await new sql.Request(pool);

  request.input("userID", sql.Int, req.user.id);
  request.input("datasetID", sql.Int, req.body.itemID);

  const query =
    "INSERT INTO [dbo].[tblUser_Dataset_Favorites] (User_ID, Dataset_ID) VALUES (@userID, @datasetID)";

  try {
    let result = await request.query(query);
  } catch (e) {
    console.log(e);
  }

  res.end();
  return next();
};

// Remove persisted favorite from DB
exports.removeCartItem = async (req, res, next) => {
  let pool = await pools.userReadAndWritePool;
  let request = new sql.Request(pool);

  request.input("userID", sql.Int, req.user.id);
  request.input("datasetID", sql.Int, req.body.itemID);

  const query =
    "DELETE FROM [dbo].[tblUser_Dataset_Favorites] WHERE User_ID = @userID AND Dataset_ID = @datasetID";

  try {
    await request.query(query);
  } catch (e) {
    console.log(e);
  }

  res.end();
  return next();
};

// Remove all persisted favorites from db
exports.clearCart = async (req, res, next) => {
  let pool = await pools.userReadAndWritePool;
  let request = new sql.Request(pool);

  request.input("userID", sql.Int, req.user.id);

  const query =
    "DELETE FROM [dbo].[tblUser_Dataset_Favorites] WHERE User_ID = @userID";

  try {
    await request.query(query);
  } catch (e) {
    console.log(e);
  }

  res.end();
  return next();
};

// Retrieve persisted favorites for a user
exports.getCart = async (req, res, next) => {
  let pool = await pools.userReadAndWritePool;
  let request = await new sql.Request(pool);

  request.input("userID", sql.Int, req.user.id);

  const query =
    datasetCatalogQuery +
    `
            AND cat.Dataset_ID IN (
                SELECT Dataset_ID
                FROM tblUser_Dataset_Favorites
                WHERE User_ID = @userID
            )
        `;

  try {
    let result = await request.query(query);
    let datasets = result.recordsets[0];
    datasets.forEach((e, i) => {
      e.Sensors = [...new Set(e.Sensors.split(","))];
    });
    res.send(JSON.stringify(datasets));
  } catch (e) {
    console.log(e);
  }

  res.end();
  return next();
};

// Generates and sends a guest token to user
exports.getGuestToken = async (req, res, next) => {
  let pool = await pools.userReadAndWritePool;

  let checkTokenLimitRequest = await new sql.Request(pool);
  let checkTokenLimitResult = await checkTokenLimitRequest.query(`
        ${sqlSegments.declareAndSetDateTimeVariables}

        SELECT * FROM [tblGuest_Tokens_Issued_Hourly]
        WHERE [Date_Time] = ${sqlSegments.dateTimeFromParts}
    `);

  if (
    checkTokenLimitResult.recordset &&
    checkTokenLimitResult.recordset.length
  ) {
    let tokensIssuedThisHour = checkTokenLimitResult.recordset[0].Tokens_Issued;
    if (tokensIssuedThisHour > 200) {
      res.sendStatus(503);
      return next();
    }
  } else {
    let addNewHourRowRequest = await new sql.Request(pool);
    let addNewHourRowResult;

    try {
      addNewHourRowResult = await addNewHourRowRequest.query(`
                ${sqlSegments.declareAndSetDateTimeVariables}
                INSERT INTO [tblGuest_Tokens_Issued_Hourly] ([Date_Time], [Tokens_Issued])
                VALUES ( ${sqlSegments.dateTimeFromParts}, 1)
            `);
    } catch (e) {
      if (e.number === 2601) {
        // another node instance inserted this row during our network call.
        //Just increment
      } else {
        console.log(e);
        res.sendStatus(503);
        return next();
      }
    }
  }

  // if you're not going to increment a row and send back a token you should have exited the function by now
  let incrementTokensIssuedRequest = await new sql.Request(pool);
  incrementTokensIssuedRequest.query(`
        ${sqlSegments.declareAndSetDateTimeVariables}
        UPDATE [tblGuest_Tokens_Issued_Hourly]
        SET [Tokens_Issued] = [Tokens_Issued] + 1
        WHERE [Date_Time] = ${sqlSegments.dateTimeFromParts}
    `);

  let hash = guestTokenHashFromRequest(req);

  let storeTokenInfoRequest = await new sql.Request(pool);
  let storeTokenInfoResult = await storeTokenInfoRequest.query(`
        INSERT INTO tblGuest_Tokens ([Hash])
        Values ('${hash}')
        SELECT SCOPE_IDENTITY() AS ID
    `);

  let token = {
    id: storeTokenInfoResult.recordset[0].ID,
    hash,
  };

  let expires = parseInt(req.query.expires);
  res.cookie(
    "guestToken",
    await jwt.sign(token, jwtConfig.secret, { expiresIn: "24h" }),
    { expires: new Date(expires) }
  );
  return res.sendStatus(200);
};
